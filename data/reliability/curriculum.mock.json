{
  "domain": "tool_use_correctness",
  "domain_ref": "field.md \u00a7 I.1",
  "scenario": "flight_booking_agent",
  "metadata": {
    "generated": "2026-02-07T10:49:50+00:00",
    "node_count": 20,
    "edge_count": 31,
    "max_depth": 4
  },
  "nodes": [
    {
      "id": "F1",
      "title": "Define Tool Interface",
      "category": "foundation",
      "layer": 0,
      "difficulty": "beginner",
      "estimated_time_minutes": 40,
      "exercise_type": "write",
      "failure_mode": "Without a clear tool contract, calls become inconsistent and unsafe.",
      "exercise": "Write a Python file (~70 lines) that defines a Tool dataclass with name, description, input_schema, and handler fields for flight booking actions.",
      "pass_condition": "Passes when each tool can be instantiated and printed with predictable fields.",
      "fail_condition": "Fails when tools are represented as ad-hoc dictionaries with missing required fields.",
      "reference_hint": "Compare your solution: explicit contracts make later validation and routing logic simple.",
      "prerequisites": [],
      "teaches": "The learner can model tool capabilities as explicit data structures.",
      "connects_to_field_map": [
        "foundational contract for all tool-use correctness modes"
      ],
      "tags": [
        "contracts",
        "dataclass",
        "tool-interface"
      ],
      "skeleton_file": "exercises/F1_define_tool_interface.py",
      "dependents": [
        "A1",
        "O1",
        "S1"
      ]
    },
    {
      "id": "F2",
      "title": "Build Tool Registry",
      "category": "foundation",
      "layer": 0,
      "difficulty": "beginner",
      "estimated_time_minutes": 40,
      "exercise_type": "write",
      "failure_mode": "If tools are not centrally registered, selection logic drifts and hallucinations slip in.",
      "exercise": "Write a Python file (~80 lines) implementing a ToolRegistry that registers tools, rejects duplicate names, and supports lookup by name.",
      "pass_condition": "Passes when valid tool names resolve and duplicate registration raises a clear error.",
      "fail_condition": "Fails when unknown tools silently resolve to None without diagnostic context.",
      "reference_hint": "Compare your solution: reliable systems separate discovery from execution with a strict registry boundary.",
      "prerequisites": [],
      "teaches": "The learner can enforce a single source of truth for available tools.",
      "connects_to_field_map": [
        "inventing tools that don't exist",
        "choosing the wrong tool"
      ],
      "tags": [
        "registry",
        "lookup",
        "tool-catalog"
      ],
      "skeleton_file": "exercises/F2_build_tool_registry.py",
      "dependents": [
        "H1",
        "O1",
        "S1"
      ]
    },
    {
      "id": "F3",
      "title": "Standardize Tool Envelope",
      "category": "foundation",
      "layer": 0,
      "difficulty": "beginner",
      "estimated_time_minutes": 45,
      "exercise_type": "write",
      "failure_mode": "Inconsistent outputs make downstream logic misread success and failure states.",
      "exercise": "Write a Python file (~90 lines) that defines a ResultEnvelope with ok, data, error_code, and message fields plus constructor helpers.",
      "pass_condition": "Passes when all tool handlers return a ResultEnvelope and callers can branch on ok safely.",
      "fail_condition": "Fails when any handler returns raw strings or mixed tuple formats.",
      "reference_hint": "Compare your solution: explicit envelopes prevent hidden coupling between caller and tool internals.",
      "prerequisites": [],
      "teaches": "The learner can normalize tool outputs for predictable orchestration.",
      "connects_to_field_map": [
        "misunderstanding tool output"
      ],
      "tags": [
        "output-envelope",
        "result",
        "contracts"
      ],
      "skeleton_file": "exercises/F3_standardize_tool_envelope.py",
      "dependents": [
        "A1",
        "O1",
        "R1"
      ]
    },
    {
      "id": "F4",
      "title": "Define Usage Policy",
      "category": "foundation",
      "layer": 0,
      "difficulty": "beginner",
      "estimated_time_minutes": 35,
      "exercise_type": "write",
      "failure_mode": "Without policy constraints, agents bypass tools and perform unsafe manual actions.",
      "exercise": "Write a Python file (~60 lines) that encodes policy rules for when flight operations must call a tool instead of manual logic.",
      "pass_condition": "Passes when policy checks return enforceable decisions for reservation and payment intents.",
      "fail_condition": "Fails when policy only logs warnings and allows unrestricted manual execution.",
      "reference_hint": "Compare your solution: policy is an executable guardrail, not documentation.",
      "prerequisites": [],
      "teaches": "The learner can formalize mandatory tool usage requirements.",
      "connects_to_field_map": [
        "ignoring available tools and doing it manually"
      ],
      "tags": [
        "policy",
        "governance",
        "guardrails"
      ],
      "skeleton_file": "exercises/F4_define_usage_policy.py",
      "dependents": [
        "V1",
        "V2"
      ]
    },
    {
      "id": "S1",
      "title": "Trigger Wrong Tool Calls",
      "category": "selection",
      "layer": 1,
      "difficulty": "intermediate",
      "estimated_time_minutes": 45,
      "exercise_type": "write",
      "failure_mode": "Picking semantically similar tools causes valid calls that produce incorrect business outcomes.",
      "exercise": "Write a Python file (~90 lines) with two booking tools where a scripted proposer intentionally picks the wrong one for a reservation flow.",
      "pass_condition": "Passes when the run log clearly shows a wrong-tool call that still executes without runtime errors.",
      "fail_condition": "Fails when the script never demonstrates incorrect selection behavior.",
      "reference_hint": "Compare your solution: reproduce the failure first so later ranking rules are justified by evidence.",
      "prerequisites": [
        "F1",
        "F2"
      ],
      "teaches": "The learner can recognize that successful execution is not equivalent to correct tool choice.",
      "connects_to_field_map": [
        "choosing the wrong tool"
      ],
      "tags": [
        "selection",
        "failure-first",
        "routing"
      ],
      "skeleton_file": "exercises/S1_trigger_wrong_tool_calls.py",
      "dependents": [
        "H2",
        "S2"
      ]
    },
    {
      "id": "A1",
      "title": "Accept Bad Arguments",
      "category": "arguments",
      "layer": 1,
      "difficulty": "intermediate",
      "estimated_time_minutes": 45,
      "exercise_type": "write",
      "failure_mode": "Malformed arguments reach tool handlers and trigger latent runtime faults.",
      "exercise": "Write a Python file (~80 lines) where reserve_seat receives missing or wrong-typed fields and still attempts execution.",
      "pass_condition": "Passes when malformed payloads are observed causing incorrect behavior in execution logs.",
      "fail_condition": "Fails when arguments are already validated and no malformed-input path is observable.",
      "reference_hint": "Compare your solution: failure demonstration should isolate which argument assumptions are currently implicit.",
      "prerequisites": [
        "F1",
        "F3"
      ],
      "teaches": "The learner can surface concrete argument-shape failures before adding schema checks.",
      "connects_to_field_map": [
        "passing malformed arguments"
      ],
      "tags": [
        "arguments",
        "validation",
        "failure-first"
      ],
      "skeleton_file": "exercises/A1_accept_bad_arguments.py",
      "dependents": [
        "A2",
        "R2"
      ]
    },
    {
      "id": "O1",
      "title": "Break Call Ordering",
      "category": "ordering",
      "layer": 1,
      "difficulty": "intermediate",
      "estimated_time_minutes": 50,
      "exercise_type": "write",
      "failure_mode": "Correct tools in the wrong sequence create invalid state transitions such as payment-before-reservation.",
      "exercise": "Write a Python file (~100 lines) that executes process_payment before reserve_seat and logs resulting inconsistency.",
      "pass_condition": "Passes when the simulation records payment success followed by reservation failure or mismatch.",
      "fail_condition": "Fails when flow always follows the safe order and cannot reproduce sequencing bugs.",
      "reference_hint": "Compare your solution: ordering bugs are state bugs, so keep state snapshots around each call.",
      "prerequisites": [
        "F1",
        "F2",
        "F3"
      ],
      "teaches": "The learner can demonstrate why tool-call sequencing needs explicit control.",
      "connects_to_field_map": [
        "calling tools in the wrong order"
      ],
      "tags": [
        "ordering",
        "state",
        "workflow"
      ],
      "skeleton_file": "exercises/O1_break_call_ordering.py",
      "dependents": [
        "O2"
      ]
    },
    {
      "id": "R1",
      "title": "Misread Tool Output",
      "category": "output",
      "layer": 1,
      "difficulty": "intermediate",
      "estimated_time_minutes": 45,
      "exercise_type": "write",
      "failure_mode": "If callers misinterpret tool envelopes, they treat recoverable errors as success.",
      "exercise": "Write a Python file (~80 lines) where caller logic checks only message text and ignores the ok flag in ResultEnvelope.",
      "pass_condition": "Passes when at least one failed tool call is incorrectly treated as successful in logs.",
      "fail_condition": "Fails when caller logic consistently interprets ok and error_code correctly.",
      "reference_hint": "Compare your solution: when parsing outputs, make success conditions explicit and machine-checkable.",
      "prerequisites": [
        "F3"
      ],
      "teaches": "The learner can identify output interpretation bugs even when tool responses look human-readable.",
      "connects_to_field_map": [
        "misunderstanding tool output"
      ],
      "tags": [
        "output",
        "parsing",
        "failure-first"
      ],
      "skeleton_file": "exercises/R1_misread_tool_output.py",
      "dependents": [
        "R2"
      ]
    },
    {
      "id": "H1",
      "title": "Call Invented Tool",
      "category": "hallucination",
      "layer": 1,
      "difficulty": "intermediate",
      "estimated_time_minutes": 40,
      "exercise_type": "write",
      "failure_mode": "Hallucinated tool names bypass intent and produce undefined runtime behavior.",
      "exercise": "Write a Python file (~70 lines) that attempts to call a non-existent tool like auto_upgrade_ticket and observe runtime handling.",
      "pass_condition": "Passes when unknown tool invocation is captured as a concrete failure case.",
      "fail_condition": "Fails when unknown tool names are silently rewritten or ignored.",
      "reference_hint": "Compare your solution: explicit unknown-tool errors are a product feature, not just a developer convenience.",
      "prerequisites": [
        "F2"
      ],
      "teaches": "The learner can reproduce tool hallucination failures with deterministic scripts.",
      "connects_to_field_map": [
        "inventing tools that don't exist"
      ],
      "tags": [
        "hallucination",
        "registry",
        "errors"
      ],
      "skeleton_file": "exercises/H1_call_invented_tool.py",
      "dependents": [
        "H2"
      ]
    },
    {
      "id": "V1",
      "title": "Bypass Tools Manually",
      "category": "avoidance",
      "layer": 1,
      "difficulty": "intermediate",
      "estimated_time_minutes": 40,
      "exercise_type": "write",
      "failure_mode": "Manual fallback logic can bypass audited tool controls and break reliability guarantees.",
      "exercise": "Write a Python file (~70 lines) where the agent manually mutates booking state instead of calling reserve_seat.",
      "pass_condition": "Passes when manual bypass succeeds and creates state not recorded through tool logs.",
      "fail_condition": "Fails when every state mutation still routes through registered tool handlers.",
      "reference_hint": "Compare your solution: if behavior matters, policy must gate side effects, not just suggest tools.",
      "prerequisites": [
        "F4"
      ],
      "teaches": "The learner can expose the risk of tool avoidance in deterministic agent loops.",
      "connects_to_field_map": [
        "ignoring available tools and doing it manually"
      ],
      "tags": [
        "avoidance",
        "policy",
        "safety"
      ],
      "skeleton_file": "exercises/V1_bypass_tools_manually.py",
      "dependents": [
        "V2"
      ]
    },
    {
      "id": "S2",
      "title": "Add Selection Scoring",
      "category": "selection",
      "layer": 2,
      "difficulty": "intermediate",
      "estimated_time_minutes": 55,
      "exercise_type": "write",
      "failure_mode": "Without explicit ranking checks, wrong-tool choices persist in ambiguous prompts.",
      "exercise": "Write a Python file (~110 lines) adding deterministic selection scoring that ranks tools by intent match and required fields.",
      "pass_condition": "Passes when previously wrong selections from S1 are corrected under the same scripted inputs.",
      "fail_condition": "Fails when scoring cannot distinguish reserve_seat from semantically nearby tools.",
      "reference_hint": "Compare your solution: keep the scoring explainable so failures can be audited quickly.",
      "prerequisites": [
        "S1"
      ],
      "teaches": "The learner can implement deterministic mitigation for wrong-tool selection.",
      "connects_to_field_map": [
        "choosing the wrong tool"
      ],
      "tags": [
        "selection",
        "ranking",
        "mitigation"
      ],
      "skeleton_file": "exercises/S2_add_selection_scoring.py",
      "dependents": []
    },
    {
      "id": "A2",
      "title": "Enforce Argument Schemas",
      "category": "arguments",
      "layer": 2,
      "difficulty": "intermediate",
      "estimated_time_minutes": 55,
      "exercise_type": "write",
      "failure_mode": "Absent schema checks allow malformed payloads to corrupt booking and payment state.",
      "exercise": "Write a Python file (~110 lines) that validates required keys, types, and range constraints before tool execution.",
      "pass_condition": "Passes when malformed payloads from A1 are rejected with structured validation errors.",
      "fail_condition": "Fails when malformed arguments still reach tool handlers.",
      "reference_hint": "Compare your solution: fail fast at the boundary and return machine-readable error details.",
      "prerequisites": [
        "A1"
      ],
      "teaches": "The learner can implement argument validation as a first-line reliability control.",
      "connects_to_field_map": [
        "passing malformed arguments"
      ],
      "tags": [
        "arguments",
        "schema",
        "validation"
      ],
      "skeleton_file": "exercises/A2_enforce_argument_schemas.py",
      "dependents": [
        "D1",
        "D2"
      ]
    },
    {
      "id": "O2",
      "title": "Gate Execution Order",
      "category": "ordering",
      "layer": 2,
      "difficulty": "intermediate",
      "estimated_time_minutes": 55,
      "exercise_type": "write",
      "failure_mode": "Without precondition gates, legal tools can still run in invalid sequences.",
      "exercise": "Write a Python file (~110 lines) that enforces workflow preconditions such as reservation_id required before payment.",
      "pass_condition": "Passes when out-of-order calls from O1 are blocked with explicit precondition errors.",
      "fail_condition": "Fails when payment still executes before reservation is confirmed.",
      "reference_hint": "Compare your solution: represent workflow invariants as code, not comments in handlers.",
      "prerequisites": [
        "O1"
      ],
      "teaches": "The learner can prevent sequencing bugs by encoding state preconditions.",
      "connects_to_field_map": [
        "calling tools in the wrong order"
      ],
      "tags": [
        "ordering",
        "preconditions",
        "workflow"
      ],
      "skeleton_file": "exercises/O2_gate_execution_order.py",
      "dependents": [
        "D1",
        "D3"
      ]
    },
    {
      "id": "R2",
      "title": "Validate Output Semantics",
      "category": "output",
      "layer": 2,
      "difficulty": "intermediate",
      "estimated_time_minutes": 50,
      "exercise_type": "write",
      "failure_mode": "Unchecked output semantics let downstream code act on incomplete or contradictory responses.",
      "exercise": "Write a Python file (~100 lines) adding output validators that reject envelopes with missing keys or contradictory ok/error states.",
      "pass_condition": "Passes when misread cases from R1 are caught before business state updates.",
      "fail_condition": "Fails when ambiguous envelopes are accepted as success.",
      "reference_hint": "Compare your solution: output validation belongs at the caller boundary, not only inside tools.",
      "prerequisites": [
        "R1",
        "A1"
      ],
      "teaches": "The learner can harden result interpretation with explicit semantic checks.",
      "connects_to_field_map": [
        "misunderstanding tool output"
      ],
      "tags": [
        "output",
        "validation",
        "semantics"
      ],
      "skeleton_file": "exercises/R2_validate_output_semantics.py",
      "dependents": [
        "D1",
        "D2"
      ]
    },
    {
      "id": "H2",
      "title": "Reject Unknown Tools",
      "category": "hallucination",
      "layer": 2,
      "difficulty": "intermediate",
      "estimated_time_minutes": 45,
      "exercise_type": "write",
      "failure_mode": "If unknown tool calls are not hard failures, agent behavior becomes non-deterministic and unsafe.",
      "exercise": "Write a Python file (~90 lines) that blocks unknown tool names and returns deterministic unknown_tool errors with suggestion hints.",
      "pass_condition": "Passes when invented tools from H1 are rejected and logged with consistent error metadata.",
      "fail_condition": "Fails when hallucinated names are executed through fallback code paths.",
      "reference_hint": "Compare your solution: unknown-tool handling should be deterministic and observable.",
      "prerequisites": [
        "H1",
        "S1"
      ],
      "teaches": "The learner can enforce strict registry membership at execution time.",
      "connects_to_field_map": [
        "inventing tools that don't exist"
      ],
      "tags": [
        "hallucination",
        "registry",
        "mitigation"
      ],
      "skeleton_file": "exercises/H2_reject_unknown_tools.py",
      "dependents": [
        "D2",
        "D3"
      ]
    },
    {
      "id": "V2",
      "title": "Enforce Mandatory Tooling",
      "category": "avoidance",
      "layer": 2,
      "difficulty": "intermediate",
      "estimated_time_minutes": 50,
      "exercise_type": "write",
      "failure_mode": "Policy gaps permit manual side effects that bypass validation and audit trails.",
      "exercise": "Write a Python file (~95 lines) adding a runtime guard that blocks state mutations unless initiated by approved tools.",
      "pass_condition": "Passes when manual bypass attempts from V1 are denied and produce policy violation events.",
      "fail_condition": "Fails when direct state writes still succeed outside tool handlers.",
      "reference_hint": "Compare your solution: mandatory-tool enforcement should guard writes, not only intent parsing.",
      "prerequisites": [
        "V1",
        "F4"
      ],
      "teaches": "The learner can enforce that critical operations always flow through audited tools.",
      "connects_to_field_map": [
        "ignoring available tools and doing it manually"
      ],
      "tags": [
        "avoidance",
        "policy",
        "enforcement"
      ],
      "skeleton_file": "exercises/V2_enforce_mandatory_tooling.py",
      "dependents": [
        "D3"
      ]
    },
    {
      "id": "D1",
      "title": "Debug Runtime Regression",
      "category": "debug",
      "layer": 3,
      "difficulty": "advanced",
      "estimated_time_minutes": 70,
      "exercise_type": "debug",
      "failure_mode": "Combined ordering, argument, and output defects hide each other and delay root-cause discovery.",
      "exercise": "Here is a broken tool runtime. Find 4 bugs spanning call ordering, argument checks, and output handling, then explain each mapped failure mode.",
      "pass_condition": "Passes when all injected bugs are fixed and scenario tests show deterministic safe outcomes.",
      "fail_condition": "Fails when at least one bug category remains unresolved or unmapped.",
      "reference_hint": "Compare your solution: triage by boundary first, then move inward to handlers.",
      "prerequisites": [
        "O2",
        "A2",
        "R2"
      ],
      "teaches": "The learner can systematically debug interacting correctness failures in a tool runtime.",
      "connects_to_field_map": [
        "wrong_call_order",
        "malformed_arguments",
        "output_misinterpretation"
      ],
      "tags": [
        "debug",
        "runtime",
        "triage"
      ],
      "skeleton_file": "exercises/D1_debug_runtime_regression.py",
      "dependents": [
        "C1"
      ]
    },
    {
      "id": "D2",
      "title": "Read Runtime Contracts",
      "category": "debug",
      "layer": 3,
      "difficulty": "advanced",
      "estimated_time_minutes": 60,
      "exercise_type": "read",
      "failure_mode": "Without reading production contract code, learners miss how safeguards are implemented in practice.",
      "exercise": "Read agent-runtime files contracts.py and envelope.py, then map each component to earlier safeguards for arguments, output semantics, and unknown tool handling.",
      "pass_condition": "Passes when the learner produces a mapping document that correctly links runtime components to prior node concepts.",
      "fail_condition": "Fails when mappings are generic and cannot tie code elements to specific failure modes.",
      "reference_hint": "Compare your solution: reliable production code usually centralizes contracts to reduce duplicated checks.",
      "prerequisites": [
        "A2",
        "R2",
        "H2"
      ],
      "teaches": "The learner can interpret production reliability code and connect it to design principles.",
      "connects_to_field_map": [
        "output_misinterpretation",
        "tool_hallucination",
        "malformed_arguments"
      ],
      "tags": [
        "read",
        "contracts",
        "production-code"
      ],
      "skeleton_file": "exercises/D2_read_runtime_contracts.md",
      "dependents": [
        "C1"
      ]
    },
    {
      "id": "D3",
      "title": "Debug Policy and Ordering",
      "category": "debug",
      "layer": 3,
      "difficulty": "advanced",
      "estimated_time_minutes": 65,
      "exercise_type": "debug",
      "failure_mode": "Policy bypass and ordering regressions can combine into silent data corruption.",
      "exercise": "Here is a mixed-failure booking trace. Find 3 defects across tool avoidance, call ordering, and unknown tool routing; patch and justify each fix.",
      "pass_condition": "Passes when patched run blocks bypasses, rejects unknown tools, and enforces legal sequencing.",
      "fail_condition": "Fails when any one of the three safeguards remains bypassable in replay tests.",
      "reference_hint": "Compare your solution: mixed-failure debugging is faster when you classify each log event by guardrail layer.",
      "prerequisites": [
        "V2",
        "O2",
        "H2"
      ],
      "teaches": "The learner can debug cross-cutting failures involving policy, routing, and workflow controls.",
      "connects_to_field_map": [
        "tool_avoidance",
        "wrong_call_order",
        "tool_hallucination"
      ],
      "tags": [
        "debug",
        "policy",
        "ordering"
      ],
      "skeleton_file": "exercises/D3_debug_policy_and_ordering.py",
      "dependents": [
        "C1"
      ]
    },
    {
      "id": "C1",
      "title": "Integrate Adversarial Runtime",
      "category": "capstone",
      "layer": 4,
      "difficulty": "advanced",
      "estimated_time_minutes": 90,
      "exercise_type": "integrate",
      "failure_mode": "Without end-to-end integration, isolated safeguards can still leave exploitable gaps.",
      "exercise": "Write a Python file (~200 lines) integrating registry, selection, ordering, argument validation, output checks, hallucination rejection, and policy enforcement; run an adversarial scripted proposer and report caught vs missed failures.",
      "pass_condition": "Passes when adversarial scenarios are executed and results clearly classify prevented versus uncaught failure modes.",
      "fail_condition": "Fails when the final runtime cannot explain which failures were blocked and why.",
      "reference_hint": "Compare your solution: synthesis quality comes from clear boundaries plus observable guardrail decisions.",
      "prerequisites": [
        "D1",
        "D2",
        "D3"
      ],
      "teaches": "The learner can assemble a robust deterministic tool runtime and evaluate its reliability envelope.",
      "connects_to_field_map": [
        "all domain 1 failure modes"
      ],
      "tags": [
        "capstone",
        "integration",
        "adversarial"
      ],
      "skeleton_file": "exercises/C1_integrate_adversarial_runtime.py",
      "dependents": []
    }
  ],
  "edges": [
    {
      "from": "F1",
      "to": "S1",
      "type": "prerequisite",
      "relationship": "F1 provides prerequisite capability for S1"
    },
    {
      "from": "F2",
      "to": "S1",
      "type": "prerequisite",
      "relationship": "F2 provides prerequisite capability for S1"
    },
    {
      "from": "F1",
      "to": "A1",
      "type": "prerequisite",
      "relationship": "F1 provides prerequisite capability for A1"
    },
    {
      "from": "F3",
      "to": "A1",
      "type": "prerequisite",
      "relationship": "F3 provides prerequisite capability for A1"
    },
    {
      "from": "F1",
      "to": "O1",
      "type": "prerequisite",
      "relationship": "F1 provides prerequisite capability for O1"
    },
    {
      "from": "F2",
      "to": "O1",
      "type": "prerequisite",
      "relationship": "F2 provides prerequisite capability for O1"
    },
    {
      "from": "F3",
      "to": "O1",
      "type": "prerequisite",
      "relationship": "F3 provides prerequisite capability for O1"
    },
    {
      "from": "F3",
      "to": "R1",
      "type": "prerequisite",
      "relationship": "F3 provides prerequisite capability for R1"
    },
    {
      "from": "F2",
      "to": "H1",
      "type": "prerequisite",
      "relationship": "F2 provides prerequisite capability for H1"
    },
    {
      "from": "F4",
      "to": "V1",
      "type": "prerequisite",
      "relationship": "F4 provides prerequisite capability for V1"
    },
    {
      "from": "S1",
      "to": "S2",
      "type": "prerequisite",
      "relationship": "S1 provides prerequisite capability for S2"
    },
    {
      "from": "A1",
      "to": "A2",
      "type": "prerequisite",
      "relationship": "A1 provides prerequisite capability for A2"
    },
    {
      "from": "O1",
      "to": "O2",
      "type": "prerequisite",
      "relationship": "O1 provides prerequisite capability for O2"
    },
    {
      "from": "R1",
      "to": "R2",
      "type": "prerequisite",
      "relationship": "R1 provides prerequisite capability for R2"
    },
    {
      "from": "A1",
      "to": "R2",
      "type": "prerequisite",
      "relationship": "A1 provides prerequisite capability for R2"
    },
    {
      "from": "H1",
      "to": "H2",
      "type": "prerequisite",
      "relationship": "H1 provides prerequisite capability for H2"
    },
    {
      "from": "S1",
      "to": "H2",
      "type": "prerequisite",
      "relationship": "S1 provides prerequisite capability for H2"
    },
    {
      "from": "V1",
      "to": "V2",
      "type": "prerequisite",
      "relationship": "V1 provides prerequisite capability for V2"
    },
    {
      "from": "F4",
      "to": "V2",
      "type": "prerequisite",
      "relationship": "F4 provides prerequisite capability for V2"
    },
    {
      "from": "O2",
      "to": "D1",
      "type": "prerequisite",
      "relationship": "O2 provides prerequisite capability for D1"
    },
    {
      "from": "A2",
      "to": "D1",
      "type": "prerequisite",
      "relationship": "A2 provides prerequisite capability for D1"
    },
    {
      "from": "R2",
      "to": "D1",
      "type": "prerequisite",
      "relationship": "R2 provides prerequisite capability for D1"
    },
    {
      "from": "A2",
      "to": "D2",
      "type": "prerequisite",
      "relationship": "A2 provides prerequisite capability for D2"
    },
    {
      "from": "R2",
      "to": "D2",
      "type": "prerequisite",
      "relationship": "R2 provides prerequisite capability for D2"
    },
    {
      "from": "H2",
      "to": "D2",
      "type": "prerequisite",
      "relationship": "H2 provides prerequisite capability for D2"
    },
    {
      "from": "V2",
      "to": "D3",
      "type": "prerequisite",
      "relationship": "V2 provides prerequisite capability for D3"
    },
    {
      "from": "O2",
      "to": "D3",
      "type": "prerequisite",
      "relationship": "O2 provides prerequisite capability for D3"
    },
    {
      "from": "H2",
      "to": "D3",
      "type": "prerequisite",
      "relationship": "H2 provides prerequisite capability for D3"
    },
    {
      "from": "D1",
      "to": "C1",
      "type": "prerequisite",
      "relationship": "D1 provides prerequisite capability for C1"
    },
    {
      "from": "D2",
      "to": "C1",
      "type": "prerequisite",
      "relationship": "D2 provides prerequisite capability for C1"
    },
    {
      "from": "D3",
      "to": "C1",
      "type": "prerequisite",
      "relationship": "D3 provides prerequisite capability for C1"
    }
  ],
  "learning_path": {
    "topological_order": [
      "F1",
      "F2",
      "F3",
      "F4",
      "S1",
      "A1",
      "O1",
      "R1",
      "H1",
      "V1",
      "S2",
      "A2",
      "O2",
      "R2",
      "H2",
      "V2",
      "D1",
      "D2",
      "D3",
      "C1"
    ],
    "critical_path": [
      "F1",
      "O1",
      "O2",
      "D1",
      "C1"
    ],
    "estimated_total_hours": 18.3
  },
  "milestones": [
    {
      "id": "MS1",
      "name": "Foundations and Contracts",
      "nodes": [
        "F1",
        "F2",
        "F3",
        "F4"
      ],
      "after_this": "You can model tools, registry boundaries, result envelopes, and usage policy in code.",
      "estimated_hours": 2.7
    },
    {
      "id": "MS2",
      "name": "Failure Demonstrations",
      "nodes": [
        "S1",
        "A1",
        "O1",
        "R1",
        "H1",
        "V1"
      ],
      "after_this": "You can reproduce each major tool-use correctness failure mode in a controlled script.",
      "estimated_hours": 4.5
    },
    {
      "id": "MS3",
      "name": "Mitigation Guardrails",
      "nodes": [
        "S2",
        "A2",
        "O2",
        "R2",
        "H2",
        "V2"
      ],
      "after_this": "You can implement deterministic safeguards that block wrong selections, bad arguments, bad ordering, and unsafe bypasses.",
      "estimated_hours": 5.2
    },
    {
      "id": "MS4",
      "name": "Debug and Read",
      "nodes": [
        "D1",
        "D2",
        "D3"
      ],
      "after_this": "You can debug multi-failure traces and map production runtime code to reliability concepts.",
      "estimated_hours": 3.2
    },
    {
      "id": "MS5",
      "name": "Capstone Integration",
      "nodes": [
        "C1"
      ],
      "after_this": "You can assemble and evaluate an end-to-end reliable flight booking tool runtime.",
      "estimated_hours": 1.5
    }
  ],
  "coverage_map": {
    "choosing_wrong_tool": [
      "S1",
      "S2",
      "D1",
      "C1"
    ],
    "wrong_call_order": [
      "O1",
      "O2",
      "D1",
      "D3",
      "C1"
    ],
    "malformed_arguments": [
      "A1",
      "A2",
      "D1",
      "D2",
      "C1"
    ],
    "output_misinterpretation": [
      "R1",
      "R2",
      "D1",
      "D2",
      "C1"
    ],
    "tool_hallucination": [
      "H1",
      "H2",
      "D2",
      "D3",
      "C1"
    ],
    "tool_avoidance": [
      "V1",
      "V2",
      "D3",
      "C1"
    ]
  },
  "pattern_coverage_map": {}
}
